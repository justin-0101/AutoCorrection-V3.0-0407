"""
User Management Async Tasks Module
Handle asynchronous tasks related to user management
"""
import logging
import json
import time
from datetime import datetime
from celery import shared_task
from pathlib import Path
import sys

# Ensure working directory is correct
ROOT_DIR = Path(__file__).resolve().parent.parent
if str(ROOT_DIR) not in sys.path:
    sys.path.append(str(ROOT_DIR))

from app.models.user import User
from app.models.db import db
from app.extensions import db as db_ext
from services.email_service import EmailService
from utils.websocket_manager import notify_user
# Import Flask application
from run import app

# Get logger
logger = logging.getLogger(__name__)

@shared_task(name='tasks.user_tasks.send_welcome_email')
def send_welcome_email(user_id, email, username):
    """
    Send welcome email
    
    Args:
        user_id: User ID
        email: User email
        username: Username
    """
    try:
        email_service = EmailService()
        result = email_service.send_welcome_email(email, username)
        
        # Record email sending result
        logger.info(f"Welcome email sent, User ID: {user_id}, Result: {result}")
        return {"status": "success", "message": "Welcome email sent"}
    
    except Exception as e:
        logger.error(f"Failed to send welcome email, User ID: {user_id}: {str(e)}")
        return {"status": "error", "message": str(e)}

@shared_task(name='tasks.user_tasks.send_password_reset')
def send_password_reset(user_id, email, reset_token):
    """
    Send password reset email
    
    Args:
        user_id: User ID
        email: User email
        reset_token: Reset token
    """
    try:
        email_service = EmailService()
        result = email_service.send_password_reset_email(email, reset_token)
        
        # Record email sending result
        logger.info(f"Password reset email sent, User ID: {user_id}, Result: {result}")
        return {"status": "success", "message": "Password reset email sent"}
    
    except Exception as e:
        logger.error(f"Failed to send password reset email, User ID: {user_id}: {str(e)}")
        return {"status": "error", "message": str(e)}

@shared_task(name='tasks.user_tasks.reset_monthly_essay_count')
def reset_monthly_essay_count():
    """
    Reset users' monthly essay count limit
    Usually scheduled by Celery Beat, runs once per month
    """
    try:
        today = datetime.now()
        logger.info(f"Starting reset of user monthly essay counts. Current date: {today.strftime('%Y-%m-%d')}")
        
        # Find users that need to be reset
        with app.app_context():
            with db.session() as session:
                profiles = session.query(UserProfile).all()
                reset_count = 0
                
                for profile in profiles:
                    # Check if reset is needed
                    if profile.reset_date is None or \
                       (today - profile.reset_date).days >= 30:
                        
                        # Reset monthly usage
                        profile.essay_monthly_used = 0
                        profile.reset_date = today
                        reset_count += 1
                
                # Commit all changes
                if reset_count > 0:
                    session.commit()
                
        logger.info(f"Monthly essay count reset completed, total reset: {reset_count} users")
        return {
            "status": "success", 
            "reset_count": reset_count,
            "message": f"Reset {reset_count} users' monthly essay count limits"
        }
    
    except Exception as e:
        logger.error(f"Failed to reset monthly essay count: {str(e)}")
        return {"status": "error", "message": str(e)}

@shared_task(name='tasks.user_tasks.process_subscription')
def process_subscription(user_id, payment_id, plan_id, amount):
    """
    Process user subscription
    
    Args:
        user_id: User ID
        payment_id: Payment ID
        plan_id: Subscription plan ID
        amount: Payment amount
    """
    try:
        from services.payment_service import PaymentService
        
        logger.info(f"Starting to process user subscription, User ID: {user_id}, Payment ID: {payment_id}")
        
        # Verify payment status
        payment_service = PaymentService()
        payment_status = payment_service.verify_payment(payment_id)
        
        if payment_status.get('status') != 'success':
            logger.warning(f"Payment verification failed, User ID: {user_id}, Payment ID: {payment_id}")
            return {
                "status": "error",
                "message": "Payment verification failed",
                "payment_status": payment_status
            }
        
        # Get subscription plan details
        plan_details = payment_service.get_plan_details(plan_id)
        duration_days = plan_details.get('duration_days', 30)
        essay_limit = plan_details.get('essay_limit', 5)
        
        # Update user subscription
        with app.app_context():
            with db.session() as session:
                profile = session.query(UserProfile).filter_by(user_id=user_id).first()
                
                if profile:
                    # Calculate new expiry date
                    from datetime import datetime, timedelta
                    
                    if profile.subscription_expires and profile.subscription_expires > datetime.now():
                        # Extend existing subscription
                        profile.subscription_expires += timedelta(days=duration_days)
                    else:
                        # New subscription
                        profile.subscription_expires = datetime.now() + timedelta(days=duration_days)
                    
                    # Update essay limits
                    profile.essay_monthly_limit = essay_limit
                    profile.essay_monthly_used = 0
                    
                    session.commit()
                    
                    # Send subscription success notification
                    notify_user(user_id, {
                        "type": "subscription_updated",
                        "subscription": {
                            "expires": profile.subscription_expires.isoformat(),
                            "plan": plan_id,
                            "essay_limit": essay_limit
                        }
                    })
                    
                    logger.info(f"User subscription updated successfully, User ID: {user_id}, Expiry date: {profile.subscription_expires}")
                    
                    return {
                        "status": "success",
                        "message": "Subscription updated successfully",
                        "subscription_expires": profile.subscription_expires.isoformat(),
                        "essay_limit": essay_limit
                    }
                else:
                    logger.error(f"User profile does not exist, User ID: {user_id}")
                    return {"status": "error", "message": "User profile does not exist"}
    
    except Exception as e:
        logger.error(f"Failed to process user subscription, User ID: {user_id}: {str(e)}")
        return {"status": "error", "message": str(e)} 
