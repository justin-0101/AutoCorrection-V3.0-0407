# 代码修改指南

## 必须遵守的原则

在进行任何代码修改之前，必须严格遵守以下原则：

1. **实施计划优先**
   - 必须首先给出实施计划，而不是马上修改
   - 实施计划需要得到授权后才能执行

2. **系统性分析**
   - 根据实施计划，逐个问题进行细化实施内容
   - 每个实施内容都必须考虑整个流程和逻辑的统一性
   - 避免局部修改影响其他相关功能

3. **质量控制**
   - 每个实施内容的代码修改，需要得到授权
   - 每次修改后，都需要进行测试
   - 不接受临时方案

4. **风险管理**
   - 实施计划必须包含所有可能的风险评估
   - 必须为每个风险提供具体的解决方案
   - 必须包含完整的回滚方案

5. **测试保障**
   - 实施计划必须包含所有可能的测试用例
   - 必须覆盖功能测试和性能测试
   - 必须包含边界条件测试

6. **监控保障**
   - 实施计划必须包含所有必要的监控指标
   - 必须定义关键性能指标（KPI）
   - 必须设置监控告警阈值

7. **性能优化**
   - 实施计划必须包含性能优化方案
   - 必须定义性能基准和目标
   - 必须包含性能测试结果分析

8. **安全保障**
   - 实施计划必须包含安全增强方案
   - 必须进行安全风险评估
   - 必须遵循安全最佳实践

## 修改原则

在对代码进行任何修改之前，必须遵循以下系统性分析和修改原则：

### 1. 全局分析阶段

#### 1.1 依赖分析
- 检查修改涉及的所有相关文件
  - 模板文件 (*.html)
  - 路由文件 (*.py)
  - 模型文件 (models/*.py)
  - 测试文件 (tests/*.py)
  - 配置文件 (*.yaml, *.json)

#### 1.2 影响范围评估
- 识别直接影响
  - 字段名称更改
  - 函数签名变化
  - API 接口变动
- 识别间接影响
  - 外键关系
  - 继承关系
  - 会话存储
  - 缓存键名

#### 1.3 代码搜索
使用多种搜索方法：
- 精确搜索：使用grep搜索完全匹配
- 模糊搜索：使用语义搜索查找相关代码
- 正则搜索：查找可能的变体使用

### 2. 修改计划制定

#### 2.1 变更分类
- 必要的更改：直接相关的代码
- 关联更改：间接依赖的代码
- 可选更改：改进性质的修改

#### 2.2 更改顺序
1. 数据模型更改
2. 业务逻辑更改
3. 接口更改
4. 模板更改
5. 测试用例更改

#### 2.3 回滚计划
- 记录原始代码状态
- 准备回滚脚本
- 设置检查点

### 3. 执行阶段

#### 3.1 渐进式修改
- 小步骤修改
- 每步验证
- 保持可回滚

#### 3.2 验证清单
- 语法检查
- 类型检查
- 单元测试
- 集成测试
- 功能测试

#### 3.3 文档更新
- 更新API文档
- 更新注释
- 更新README
- 记录修改日志

### 4. 测试验证

#### 4.1 测试范围
- 修改的直接功能
- 相关的依赖功能
- 系统整体功能

#### 4.2 测试方法
- 单元测试
- 集成测试
- 端到端测试
- 性能测试（如果相关）

### 5. 部署和监控

#### 5.1 部署策略
- 分阶段部署
- 灰度发布
- 快速回滚机制

#### 5.2 监控指标
- 错误率
- 性能指标
- 用户反馈

## 最佳实践

### 代码搜索模式
```python
# 1. 精确搜索示例
grep_search("user\.user_id")

# 2. 模糊搜索示例
codebase_search("user identification and references")

# 3. 文件类型限制搜索
grep_search("user_id", include_pattern="*.py")
```

### 修改检查清单

1. [ ] 完成全局分析
2. [ ] 制定修改计划
3. [ ] 准备回滚方案
4. [ ] 执行代码修改
5. [ ] 运行测试套件
6. [ ] 更新相关文档
7. [ ] 部署和监控

### 常见陷阱

1. 忽略间接依赖
2. 未充分测试边界情况
3. 遗漏文档更新
4. 没有回滚计划
5. 一次性修改过多

## 工具使用

### 代码分析工具
- grep_search：精确文本搜索
- codebase_search：语义代码搜索
- file_search：文件名搜索

### 测试工具
- pytest：单元测试
- coverage：代码覆盖率
- pylint：代码质量检查

## 示例

### 字段重命名示例

```python
# 1. 搜索所有使用
grep_search("old_field_name")
codebase_search("references to old_field_name")

# 2. 分类修改
# 模型修改
class Model:
    new_field_name = old_field_name  # 重命名字段

# 模板修改
# old: {{ object.old_field_name }}
# new: {{ object.new_field_name }}

# 3. 测试用例更新
def test_field():
    assert obj.new_field_name == expected_value
```

### 路由修改示例

```python
# 1. 检查路由定义
@app.route('/old_path')  # 要修改的路由

# 2. 搜索使用
grep_search("url_for\('old_path'\)")

# 3. 更新模板
# old: {{ url_for('old_path') }}
# new: {{ url_for('new_path') }}

# 4. 更新测试
def test_route():
    response = client.get('/new_path')
    assert response.status_code == 200
```

## AI助手工作流程

### 1. 指令接收和分析
1. **指南回顾**
   - 在处理每个新指令前，首先完整回顾CODE_MODIFICATION_GUIDE.md文档
   - 确保理解所有修改原则和最佳实践
   - 将指令与完整的指南要求进行对照分析
   - 特别关注相关章节：
     * 必须遵守的原则
     * 修改原则（全局分析、计划制定等）
     * 最佳实践
     * 相关示例

2. **指令分类**
   - 确定指令类型（修改/新增/调试等）
   - 识别涉及的系统组件
   - 评估潜在影响范围
   - 参考指南中的变更分类方法

3. **实施计划制定**
   - 按照指南的修改计划章节制定详细计划
   - 明确每个步骤的具体操作
   - 预估可能的风险点
   - 准备回滚方案

### 2. 执行流程
1. **前置检查**
   - 验证是否满足所有必要条件
   - 确认是否需要额外信息或授权
   - 检查相关依赖是否就绪

2. **实施步骤**
   - 严格按照实施计划执行
   - 每个步骤后进行验证
   - 保持清晰的执行记录

3. **持续监控**
   - 跟踪每个修改的影响
   - 及时发现潜在问题
   - 准备随时回滚的方案

### 3. 反馈和确认
1. **结果验证**
   - 确认所有修改符合原则要求
   - 验证功能完整性
   - 检查是否有遗漏项

2. **文档更新**
   - 记录所有修改内容
   - 更新相关文档
   - 提供清晰的说明

3. **状态报告**
   - 总结执行结果
   - 指出需要注意的事项
   - 提供后续建议

## 结论

系统性的代码修改方法能够：
1. 减少错误和遗漏
2. 提高代码质量
3. 便于维护和回滚
4. 确保系统稳定性

请在每次代码修改前参考此指南，确保修改的完整性和正确性。 